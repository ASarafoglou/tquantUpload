# app.R
# Visualisation of Parameter Estimation
#
# Enter response frequencies and visualize parameter estimates
#
# Claudia Glemser, last edited: 14/Oct/16

library(shiny)
library(shinydashboard)
library(pks)
library(xtable)

############### UI ###############
ui <- dashboardPage(

  dashboardHeader(
    title = "Parameter estimation in probabilistic knowledge structures",
    titleWidth = "100%"
  ),

  dashboardSidebar(
    sidebarMenu(
      menuItem("Introduction", tabName = "theory"),
      menuItem("Your turn", tabName = "turn")
#     , menuItem("Got it?", tabName = "gotit")  
    )
  ),
  
  dashboardBody(
    tabItems(
      tabItem(tabName = "theory",
        tabsetPanel(
          tabPanel("Intro",
	    HTML(
              "<h3 align = 'center'><b> What are we going to do? </h3></b><br>
	       <div> This app refers to the presentation 'Probabilistic
	       Knowledge Structures' by Heller and Wickelmaier. It will
	       demonstrate parameter estimation in probabilistic knowledge
	       structures:</div><br><ul>
	         <li> If you want to be reminded of the three estimation
	              procedures, proceed to the tab 'Estimation methods'
	              above (For a more comprehensive overview, see the
		      presentation by Heller and Wickelmaier)</li>
	         <li> If you are already confident in your knowledge about
		      parameter estimation in probabilistic knowledge
		      structures, you can directly proceed to 'Your Turn' on
		      the left and see how changes to the observed data and
		      the assumed knowledge structure will affect parameter
		      estimation </li>
	         </ul>"
	     )
          ),


	  tabPanel("Estimation methods",
	    HTML(  
	      "<h3 align ='center'><b> The three estimation methods</b></h3>
	       <br>
	       With a given knowledge structure and observed response
	       patterns, there are three methods to estimate the parameters
	       of a basic local independence model (BLIM):
	       <br><br><ul>
	         <li> Maximum Likelihood (ML) Estimation</li>
	         <li> Minimum Discrepancy (MD) Estimation</li>
		 <li> Minimum Discrepancy ML Estimation (MDML)</li>
	       </ul><br></h5>
	       
	       <table style = 'width:100%' id = 't01'>
	       <tr>
	         <th>Method</th>
		 <th>Principle</th>
		 <th>Pros</th>
		 <th>Cons</th>
	       </tr>
	       <tr bgcolor = '#ddd'>
		 <td>ML</td>
		 <td>estimates parameters that maximize the probability of the
		      observed data</td>
		  <td><ul>
		        <li> driven by the likelihood of the data</li>
		        <li> (approximately) unbiased estimates </li>
		      </ul>
		  </td>
		  <td><ul>
		        <li> iterative (EM algorithm) </li>
		        <li> might inflate error rates for good fit </li>
		      </ul>
		  </td>
		</tr>
		<tr bgcolor = '#fff'>
		  <td>MD</td>
		  <td>assumes that any response pattern is generated by the
		  knowledge state closest to it</td>
		  <td><ul>
		    <li> computationally efficient (explicit estimators) </li>
		    <li> avoids inflating the error rates </li>
		  </ul>
		  <td><ul>
		    <li> ignores the likelihood of the data </li>
		    <li> estimates not unbiased </li>
		  </ul></td>
		</tr>
		<tr bgcolor = '#ddd'>
		  <td>MDML</td>
		  <td>ML estimation under certain MD restrictions</td>
		  <td><ul>
		    <li>minimizes the expected number of response errors</li>
		    <li>maximizes the likelihood under this constraint</li>
		    <li>reference for quantifying the amount of fit obtained
		        by inflating error rates</li>
		  </ul></td>
		  <td><ul> 
		    <li> estimates not unbiased </li>
		  </ul></td>
		</tr>
	      </table>"),
	      
            tags$head(tags$style(HTML(
	      "table, th, td {
                border: 1px solid black;
                border-collapse: collapse;
              }

              th {
	        text-align: center;
	      }
	      
	      th, td {
	        padding: 10px;
	      }
	      
	      table#t01 th {
	        background-color: #367fa9;
	        color: white;
              }")))	      
          )
        )
      ),

      tabItem(tabName = "turn",
        tabsetPanel(
          tabPanel("Response frequencies",
            HTML(
	      "<h4 align='center'> For this example, we will be working with a
	      knowledge domain of four items: Q = {a,b,c,d}</h4>"),
	    br(),
	    h4(strong("1) Set the observed response frequencies of ...")),
	    br(), 
            fluidRow(
              column(1,
                numericInput("NR1", HTML("&#8709"), value = 15,
                  min = 0, max = 100, step = 1),
                numericInput("NR2", "{a}", value = 4,
                  min = 0, max = 100, step = 1)),

	      column(1,
                numericInput("NR3", "{b}", value = 6, 
                  min = 0, max = 100, step = 1),
                numericInput("NR4", "{c}", value = 4,
                  min = 0, max = 100, step = 1)),

              column(1,
	        numericInput("NR5", "{d}", value = 5,
                  min = 0, max = 100, step = 1),
                numericInput("NR6", "{a,b}", value = 2,
                  min = 0, max = 100, step = 1)),

	      column(1,
                numericInput("NR7", "{a,c}", value = 3,
                  min = 0, max = 100, step = 1),
                numericInput("NR8", "{a,d}", value = 4,
                  min = 0, max = 100, step = 1)),

              column(1,
                numericInput("NR9", "{b,c}", value = 18,
                  min = 0, max = 100, step = 1),
                numericInput("NR10", "{b,d}", value = 22,
                  min = 0, max = 100, step = 1)),
	
              column(1,
                numericInput("NR11", "{c,d}", value = 2,
                  min = 0, max = 100, step = 1),
                numericInput("NR12", "{a,b,c}", value = 39,
                  min = 0, max = 100, step = 1)),
		    
	      column(1,
                numericInput("NR13", "{a,b,d}", value = 37,
                  min = 0, max = 100, step = 1),
                numericInput("NR14", "{a,c,d}", value = 12,
                  min = 0, max = 100, step = 1)),

	      column(1,
                numericInput("NR15", "{b,c,d}", value = 7,
                  min = 0, max = 100, step = 1),
                numericInput("NR16", "{a,b,c,d}", value = 20,
                  min = 0, max = 100, step = 1)),

	      column(4,
		br(),
		actionButton("go.plot", "Submit frequencies N.R")
	      )
            ),
            
            fluidRow(
	      column(12,
	        plotOutput("plot.NR")
              )
            )	      
          ),

	  tabPanel("Knowledge structure",   
	    fluidRow(
              column(4,
	        HTML("<b><h4>2) Set your knowledge structure</b> &#119974
		     </h4>"),
                checkboxGroupInput("Ks", NULL,
                c("0" = "0000", "{a}" = "1000", "{b}" = "0100",
                  "{c}" = "0010", "{d}" = "0001",
                  "{a,b}" = "1100", "{a,c}" = "1010",
                  "{a,d}" = "1001", "{b,c}" = "0110",
                  "{b,d}" = "0101", "{c,d}" = "0011",
                  "{a,b,c}" = "1110", "{a,b,d}" = "1101",
                  "{a,c,d}" = "1011", "{b,c,d}" = "0111",
                  "{a,b,c,d}" = "1111"),
	        selected = c("0000", "0110", "0101", "1110", "1101",
	          "1011", "1111")
                ),
	      actionButton("go.K", "Submit knowledge structure")),
	
	      column(8,
		wellPanel(
	          h4("You have selected the following knowledge structure:",
		     br(), textOutput("text.str"), br(), uiOutput("text.corr")
	            )
	         )  
	      )    
	    )
          ),

          tabPanel("Parameter estimates",
            
            h4(strong("3) Calculate your parameter estimates")),
	    actionButton("go.para", "Calculate estimates"),

	    fluidRow(
	      column(8,
                tableOutput("tab"),

	        tags$head(
                  tags$style(HTML("
                    .shiny-output-error-validation {
                    color: red;
		    text-align: center;
		    text-transform: uppercase;
   		    }
                 ")))
	      ),

	      column(4,
		uiOutput("text.iter"),
		uiOutput("text.iden")
              )
	    ),

	    HTML("<h4><b>The error rate estimates for each item are:</b></h4>"
		 ),

	    fluidRow(
	      column(6,
                plotOutput("plot.eta")
              ),

	      column(6,
	        plotOutput("plot.beta")
              )
	    ),

	    br(),
	    HTML("<h4><b>The estimates of the state probabilities are:</b></h4>"
		 ),

	    plotOutput("plot.pi")
	  )
	)
      )
    )
  )
)


############### SERVER ###############

server <- function(input, output){

#### NR input & plot ####

  sets1 <- c("0000", "1000", "0100", "0010", "0001", "1100",  "1010", "1001",
            "0110", "0101", "0011", "1110", "1101", "1011", "0111", "1111")
  sets2 <- as.pattern(as.binmat(sets1), as.letters = TRUE)
 

  # creates table with N.R values and the corresponding sets
  N.R <- eventReactive(input$go.plot, {
    nr <- c(input$NR1, input$NR2, input$NR3, input$NR4, input$NR5, input$NR6,
	    input$NR7, input$NR8, input$NR9, input$NR10, input$NR11,
	    input$NR12, input$NR13, input$NR14, input$NR15, input$NR16)

    setNames(nr, sets1)
  })

  # function for the barplot of the N.R frequencies
  NRplot <- function(NR){
    par(mar = c(0, 4, 3, 1)) 	  
    barplot(NR,  # include x.lab? 
            horiz     = TRUE, 
            names.arg = sets2,  # or the actual sets?
            axes      = FALSE,
            cex.names = 1.3,
            las       = 2, 
            col       = "lightblue",
            xlim      = c(0, max(NR) + 2), 
	    border    = NA
	    )
    # include axis
    axis(side     = 3, 
         cex.axis = 1.3)
  }

  output$plot.NR <- renderPlot({
    NRplot(NR = N.R())
  })

#### display chosen knowledge structure ####
  
  # displays knowledge structure as text
  text.str <- eventReactive(input$go.K, {
    paste(as.pattern(as.binmat(input$Ks), as.letters = TRUE), collapse = "; ")
  })

  output$text.str <- eventReactive(input$go.K, {
    paste0("{", text.str(), "}")
  })

  output$text.corr <- eventReactive(input$go.K, {
    if(input$Ks[1] != "0000" | input$Ks[length(input$Ks)] != "1111"){
      HTML("<h4 style='color:red' align='left'> Caution! &#8709 and Q have
	   to be part of your knowledge structure!")
    } else {
      HTML("<h4 style='color:green' align='left'> Well done! Your knowledge
	   structure includes &#8709 and Q!")
    }
  })


  # convert input for knowledge structures into usable variable K
  K <- eventReactive(input$go.K, {
    matrix(as.numeric(unlist(strsplit(input$Ks, split = ""))), ncol = 4,
      byrow = TRUE, dimnames = list(input$Ks, c("a", "b", "c", "d")))
  })

#### parameter estimation with ML, MD & MDML ####
  blim.ML   <- eventReactive(input$go.para, {
      withProgress(message = "Calculating ML", value = 1, {
        blim(K(), N.R(), method = "ML")}
      )
  })

  blim.MD   <- eventReactive(input$go.para, {
    withProgress(message = "Calculating MD", value = 1, {
      blim(K(), N.R(), method = "MD")}
    )
  })

  blim.MDML <- eventReactive(input$go.para, {
    withProgress(message = "Calculating MDML", value = 1, {
      blim(K(), N.R(), method = "MDML")}
    )
  })

  
#### display estimate results and feedback messages ###
  get.data <- reactive({
      dat <- data.frame(
	   G2 = c(blim.ML()$goodness.of.fit[1], blim.MD()$goodness.of.fit[1],
		  blim.MDML()$goodness.of.fit[1]),
	   iterations = round(c(blim.ML()$iter, blim.MD()$iter,
				blim.MDML()$iter), digits = 0),
	   LogLikelihood = c(blim.ML()$loglik, blim.MD()$loglik,
		             blim.MDML()$loglik),
	   mean_careless_error = c(blim.ML()$nerror[1], blim.MD()$nerror[1],
			      blim.MDML()$nerror[1]),  # mean error
	   mean_lucky_guess = c(blim.ML()$nerror[2], blim.MD()$nerror[2],
			   blim.MDML()$nerror[2]),  # mean error
	   row.names = c("ML", "MD", "MDML")
	   )
      dat$iterations <- sprintf('%1.0f', dat$iterations) # is left-justified???
      dat
  })

  # display estimates in a table
  output$tab <- renderTable({
    validate(
      need(input$go.K > 0, "Please submit your knowledge structure"),
      need(input$go.plot > 0, "Please submit your response frequencies")
    )
    get.data()
  }, include.rownames = TRUE)

  output$text.iter <- eventReactive(input$go.para, {
    if(blim.ML()$iter > 9999 | blim.MDML()$iter > 9999){
      HTML("<h4 style='color:red' align='center'> Caution! Your estimations
	   probably did not converge! (10,000 iterations!)")
    } else {
      HTML("<h4 style='color:green' align = 'center'> Well done! Your
	   estimations converged! (<10,000 iterations!)")
    }
  })

  output$text.iden <- eventReactive(input$go.para, {
    if(dim(jacobian(blim.ML()))[2] == qr(jacobian(blim.ML()))$rank){
      HTML("<h4 style = 'color:green' align = 'center'> Well done! Your
	   parameters are locally identifiable!")
    } else {
      HTML("<h4 style = 'color:red' align = 'center'> Caution! Your parameters
	   are not locally identifiable! Consider respecifying your knowledge
	   structure.")
    }
  })

#### beta and eta plot functions ####

  betaPlot <- function(beta.ML, beta.MD, beta.MDML){

    beta <- matrix(round(c(rev(beta.ML), rev(beta.MD), rev(beta.MDML)),
			digits = 2),
		  byrow = TRUE, ncol = 4, nrow = 3)
   
    par(mai = c(.1, .6, .6, .3))

    barplot(beta, beside = TRUE,
            horiz     = TRUE, 
            names.arg = expression(beta[d], beta[c], beta[b], beta[a]),
            axes      = FALSE,
            cex.names = 2,
            las       = 2, 
            col       = c("olivedrab2", "olivedrab3", "olivedrab"),
            xlim      = c(0, 0.3),
	    legend    = c("ML", "MD", "MDML"),
	    border    = "white"
	    )
    # include axis
    axis(side     = 3, 
         cex.axis = 1.5, 
         at       = seq(0, 0.3, 0.1), 
         labels = as.character(seq(0, 0.3, 0.1)))
  }

  etaPlot <- function(eta.ML, eta.MD, eta.MDML){
    # eta.vector: vector with eta values (eta.a, eta.b, eta.c, eta.d)
    
    eta <- matrix(round(c(rev(eta.ML), rev(eta.MD), rev(eta.MDML)),
			digits = 2),
		  byrow = TRUE, ncol = 4, nrow = 3)

    par(mai = c(.1, .6, .6, .3))

    barplot(eta, beside = TRUE,
            horiz     = TRUE, 
            names.arg = expression(eta[d], eta[c], eta[b], eta[a]),
            axes      = FALSE,
            cex.names = 2,
            las       = 2,
            col       = c("olivedrab2", "olivedrab3", "olivedrab"),
            xlim      = c(0, 0.3),
	    legend    = c("ML", "MD", "MDML"),
	    border    = "white")
    axis(side = 3, cex.axis = 1.5, 
         at = seq(0, 0.3, 0.1), 
         labels = as.character(seq(0, 0.3, 0.1))
	 )
  }

  piPlot <- function(pi.ML, pi.MD, pi.MDML, pi.K){
    pis <- matrix(round(c(rev(pi.ML), rev(pi.MD), rev(pi.MDML)),
			digits = 2),
		  byrow = TRUE, ncol = length(pi.ML), nrow = 3)
    
    pi.ceil <- ceiling(max(pis*10))/10
  
    par(mai = c(.1, .6, .6, .3), mgp = c(3, .8, 0))

    barplot(pis, beside = TRUE,
            horiz     = TRUE,
	    names.arg = as.character(as.pattern(pi.K, as.letters = TRUE)), 
            axes      = FALSE,
            cex.names = 1,
            las       = 2,
            col       = c("olivedrab2", "olivedrab3", "olivedrab"),
            xlim      = c(0, pi.ceil),
	    legend    = c("ML", "MD", "MDML"),
	    border    = "white")
    axis(side = 3, cex.axis = 1.5, 
         at = seq(0, pi.ceil, 0.1), 
         labels = as.character(seq(0, pi.ceil, 0.1))
	 )
  }
    

  output$plot.beta <- renderPlot({
    etaPlot(blim.ML()$eta, blim.MD()$eta, blim.MDML()$eta)
  })

  output$plot.eta <- renderPlot({
    betaPlot(blim.ML()$beta, blim.MD()$beta, blim.MDML()$beta)
  })

  output$plot.pi  <- renderPlot({
    piPlot(blim.ML()$P.K, blim.MD()$P.K, blim.MDML()$P.K, blim.ML()$K)
  })

}


shinyApp(ui = ui, server = server)
